<!DOCTYPE html>
<html>
<meta charset='utf-8'>
<title>t-SNE Viewer</title>
<style>

#chart {
  margin-left: -40px;
  height: 800;
}

svg {
position: absolute;
top: 60px;
left: -40px;
}

text {
  font: 10px sans-serif;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.label {
  fill: #777;
}

.iteration.label {
  font: 500 196px 'Helvetica Neue';
  fill: #ddd;
}

.iteration.label.active {
  fill: #aaa;
}

.overlay {
  fill: none;
  pointer-events: all;
  cursor: ew-resize;
}

</style>

<h1>T-SNE Viewer</h1>

<p id='chart'></p>

<script src='https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/jszip/2.5.0/jszip.min.js'></script>
<script src='jszip-utils.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/pixi.js/3.0.7/pixi.min.js'></script>
<script>
// Various accessors that specify the four dimensions of data to visualize.
function x(d) { return d.x; }
function y(d) { return d.y; }
function key(d) { return d.key; }

// Chart dimensions.
var margin = {top: 19.5, right: 19.5, bottom: 19.5, left: 99.5},
    width = 800 - margin.right,
    height = 800 - margin.top - margin.bottom;

// Various scales. These domains make assumptions of data, naturally.
var xScale = d3.scale.linear().domain([-20, 20]).range([0, width]),
    yScale = d3.scale.linear().domain([-20, 20]).range([height, 0]),
    colorScale = d3.scale.category10();

// The x & y axes.
var xAxis = d3.svg.axis().orient('bottom').scale(xScale).ticks(12, d3.format(',d')),
    yAxis = d3.svg.axis().orient('left').scale(yScale).ticks(12, d3.format(',d'));

// Create the SVG container and set the origin.
var svg = d3.select('#chart').append('svg')
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
  .append('g')
    .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

// Add the x-axis.
svg.append('g')
    .attr('class', 'x axis')
    .attr('transform', 'translate(0,' + height + ')')
    .call(xAxis);

// Add the y-axis.
svg.append('g')
    .attr('class', 'y axis')
    .call(yAxis);

// Add an x-axis label.
svg.append('text')
    .attr('class', 'x label')
    .attr('text-anchor', 'end')
    .attr('x', width)
    .attr('y', height - 6);

// Add a y-axis label.
svg.append('text')
    .attr('class', 'y label')
    .attr('text-anchor', 'end')
    .attr('y', 6)
    .attr('dy', '.75em')
    .attr('transform', 'rotate(-90)');

// Add the iteration label; the value is set on transition.
var label = svg.append('text')
    .attr('class', 'iteration label')
    .attr('text-anchor', 'end')
    .attr('y', height - 24)
    .attr('x', width)
    .text('0000');

// Load the data.
d3.json('mnist.json?nocache=' + (new Date()).getTime(), function(results) {
  JSZipUtils.getBinaryContent('mnist2500.csv.zip', function(err, data) {
    if(err) {
      throw err; // or handle err
    }

    var iterations = x(results[0]).length;
    var animationDuration = 100;

    // A bisector since many nation's data is sparsely-defined.
    var bisect = d3.bisector(function(d) { return d[0]; });

    var zip = new JSZip(data);
    var mnist2500csv = zip.file("mnist2500.csv").asText();
    var digits = [];
    d3.csv.parseRows(mnist2500csv).forEach(function(row, i) {
      var digit = drawSprite(row);
      // center the sprite's anchor point
      digit.anchor.x = 0.5;
      digit.anchor.y = 0.5;

      // move the sprite to the center of the screen
      digit.position.x = (i % 28) * 28;
      digit.position.y = (i / 28) * 28;

      stage.addChild(digit);
      digits.push(digit);
    });

    // Add an overlay for the iteration label.
    var box = label.node().getBBox();

    var overlay = svg.append('rect')
          .attr('class', 'overlay')
          .attr('x', box.x)
          .attr('y', box.y)
          .attr('width', box.width)
          .attr('height', box.height)
          .on('mouseover', enableInteraction);

    // Start a transition that interpolates the data based on iteration.
    svg.transition()
        .duration(animationDuration * iterations)
        .ease('linear')
        .tween('iteration', tweenIteration)
        .each('end', enableInteraction);

    // After the transition finishes, you can mouseover to change the iteration.
    function enableInteraction() {
      var iterationScale = d3.scale.linear()
          .domain([1, iterations])
          .range([box.x + 10, box.x + box.width - 10])
          .clamp(true);

      // Cancel the current transition, if any.
      svg.transition().duration(0);

      overlay
          .on('mouseover', mouseover)
          .on('mouseout', mouseout)
          .on('mousemove', mousemove)
          .on('touchmove', mousemove);

      function mouseover() {
        label.classed('active', true);
      }

      function mouseout() {
        label.classed('active', false);
      }

      function mousemove() {
        displayIteration(iterationScale.invert(d3.mouse(this)[0]));
      }
    }

    // Tweens the entire chart by first tweening the iteration, and then the data.
    // For the interpolated data, the dots and label are redrawn.
    function tweenIteration() {
      var iteration = d3.interpolateNumber(1, iterations);
      return function(t) { displayIteration(iteration(t)); };
    }

    // Updates the display to show the specified iteration.
    function displayIteration(iteration) {
      var interpolated = interpolateData(iteration);

      var itr = Math.ceil(iteration) - 1;
      xScale.domain([-xmaxs[itr], xmaxs[itr]]);
      yScale.domain([-ymaxs[itr], ymaxs[itr]]);
      svg.select('.x.axis').call(xAxis);
      svg.select('.y.axis').call(yAxis);

      interpolated.forEach(function(data, i) {
        digits[i].position.x = xScale(data.x) + margin.left;
        digits[i].position.y = yScale(data.y) - margin.top;
      });
      animate(); //repaint
      label.text(pad(Math.round(iteration), 4));
    }

    // Interpolates the dataset for the given (fractional) iteration.
    function interpolateData(iteration) {
      return results.map(function(d) {
        return {
          key: d.key,
          label: d.label,
          x: interpolateValues(d.x, iteration),
          y: interpolateValues(d.y, iteration)
        };
      });
    }

    // Finds (and possibly interpolates) the value for the specified iteration.
    function interpolateValues(values, iteration) {
      var i = bisect.left(values, iteration, 0, values.length - 1),
          a = values[i];
      if (i > 0) {
        var b = values[i - 1],
            t = (iteration - a[0]) / (b[0] - a[0]);
        return a[1] * (1 - t) + b[1] * t;
      }
      return a[1];
    }

    // Left pad number with '0'
    function pad(n, width, z) {
      z = z || '0';
      n = n + '';
      return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
    } 

    // a soft max that tries to avoid outlier
    Array.prototype.max = function() {
      //return this.sort(function(a, b) { return a - b; })[Math.round(this.length * .90)] * 1.5;
      return Math.max.apply(null, this);
    };

    // find cumulative maximum absolute value for axis
    var xmaxs = [], ymaxs = [];
    d3.range(0, iterations).reduce(function (acc, i) {
      var xmax = Math.max(acc[0], results.map(function(d) { return Math.abs(x(d)[i][1]); }).max());
      var ymax = Math.max(acc[1], results.map(function(d) { return Math.abs(y(d)[i][1]); }).max());

      xmaxs.push(xmax);
      ymaxs.push(ymax);

      return  [xmax, ymax];
    }, [0, 0]);

    // single-sided
    Array.prototype.simpleSMM=function(N) {
      return this.map(function(x,i,v) { 
        //if(i<N-1) return NaN;
        var end = Math.min(i + N / 2, v.length);
        var filtered = v.filter(function(x2,i2) { return i2 < end && i2 >= end - N; })
        return Math.max(v[i] * 1.3, filtered.reduce(function(a,b){ return Math.max(a, b); }));
      }); 
    };
    // smooth xmaxs and ymaxs out
    xmaxs = xmaxs.simpleSMM(10);
    ymaxs = ymaxs.simpleSMM(10);
  });
});


var renderer = new PIXI.autoDetectRenderer(1024, 1024, {'transparent': true});
document.getElementById("chart").appendChild(renderer.view);

// create the root of the scene graph
var stage = new PIXI.Container();

PIXI.Texture.Draw = function (cb) {
    var canvas = document.createElement('canvas');
    if (typeof cb == 'function') cb(canvas);
    return PIXI.Texture.fromCanvas(canvas);
};

function drawSprite(row) {
  return new PIXI.Sprite(PIXI.Texture.Draw(function (canvas) {
    //we are now in a 2D context
    //you need to specify your canvas width and height otherwise it'll have a size of 0x0 and you'll get an empty sprite
    canvas.width = 28;   
    canvas.height = 28;

    var ctx = canvas.getContext('2d');  //get  canvas 2D context
    ctx.fillRect(0, 0, canvas.width, canvas.height);
 
    var pix = ctx.createImageData(canvas.width, canvas.height);
    var color = d3.rgb(colorScale(row[0]));
    for (var x = 0; x < canvas.width; x++) {
      for(var y = 0; y < canvas.height; y++) {
        var i = x * canvas.width + y + 1;
        pix.data[i * 4 - 4] = color.r;
        pix.data[i * 4 - 3] = color.g;
        pix.data[i * 4 - 2] = color.b;
        pix.data[i * 4 - 1] = row[i];
      }
    }
 
    ctx.putImageData(pix, 0, 0);    
  }));
}


// start animating
animate();

function animate() {
    //requestAnimationFrame(animate);

    // render the root container
    renderer.render(stage);
}
</script>
