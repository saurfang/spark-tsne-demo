<!DOCTYPE html>
<html>
<meta charset='utf-8'>
<title>t-SNE Viewer</title>
<style>
svg, canvas {
  position: absolute;
  left: 0;
  top: 0;
}

text {
  font: 10px sans-serif;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.label {
  fill: #777;
}

.iteration.label {
  font: 500 96px 'Helvetica Neue';
  fill: #ddd;
}

.iteration.label.active {
  fill: #aaa;
}

.overlay {
  fill: none;
  pointer-events: all;
  cursor: ew-resize;
}

p {
    white-space: nowrap;
}

</style>

<div id='chart'></div>

<script src='https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/jszip/2.5.0/jszip.min.js'></script>
<script src='jszip-utils.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/pixi.js/3.0.7/pixi.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/spin.js/2.3.2/spin.min.js'></script>
<script>
// Chart dimensions.
var margin = {top: 52.5, right: 19.5, bottom: 19.5, left: 39.5},
    width = window.innerWidth - margin.left - margin.right,
    height = window.innerHeight - margin.top - margin.bottom,
    animating = true;

// Add PIXI Renderer first
var renderer = new PIXI.autoDetectRenderer(
  width + margin.left + margin.right,
  height + margin.top + margin.bottom,
  {'transparent': true, 'antialias': true});
document.getElementById("chart").appendChild(renderer.view);

// Various scales. These domains make assumptions of data, naturally.
var xScale0 = d3.scale.linear().domain([-20, 20]).range([0, width]),
    xScale = xScale0.copy(),
    yScale0 = d3.scale.linear().domain([-20, 20]).range([height, 0]),
    yScale = yScale0.copy(),
    colorScale = d3.scale.category10();

// The x & y axes.
var xAxis = d3.svg.axis().orient('bottom').scale(xScale).ticks(12, d3.format(',d')),
    yAxis = d3.svg.axis().orient('left').scale(yScale).ticks(12, d3.format(',d'));

// Create the SVG container and set the origin.
var svg = d3.select('#chart').append('svg')
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append('g')
    .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

// Add the x-axis.
var xAxisElement = svg.append('g')
    .attr('class', 'x axis')
    .attr('transform', 'translate(0,' + height + ')')
    .call(xAxis);

// Add the y-axis.
var yAxisElement = svg.append('g')
    .attr('class', 'y axis')
    .call(yAxis);

// Add an x-axis label.
svg.append('text')
    .attr('class', 'x label')
    .attr('text-anchor', 'end')
    .attr('x', width)
    .attr('y', height - 6);

// Add a y-axis label.
svg.append('text')
    .attr('class', 'y label')
    .attr('text-anchor', 'end')
    .attr('y', 6)
    .attr('dy', '.75em')
    .attr('transform', 'rotate(-90)');

// Add the iteration label; the value is set on transition.
var label = svg.append('text')
    .attr('class', 'iteration label')
    .attr('text-anchor', 'end')
    .attr('y', height - 24)
    .attr('x', width)
    .text('000');

// add spinner for loading
var spinner = new Spinner().spin(document.body);
var spinnerText = document.createElement('p');
spinnerText.innerText = "Loading t-SNE data...";
spinner.el.appendChild(spinnerText);
// Load the data.
d3.json('mnist.json?nocache=' + (new Date()).getTime(), function(tsneData) {
  spinnerText.innerText = "Loading image data...";
  JSZipUtils.getBinaryContent('mnist2500.csv.zip', function(err, imageData) {
    if(err) {
      throw err; // or handle err
    }

    var iterations = tsneData.iterations,
        maxIteration = iterations.max(),
        results = tsneData.results,
        animationDuration = 100;

    spinnerText.innerText = "Unzipping image data...";
    var zip = new JSZip(imageData);
    var digits = [];
    d3.csv.parseRows(zip.file("mnist2500.csv").asText()).forEach(function(row, i) {
      var digit = drawSprite(row);
      // center the sprite's anchor point
      digit.anchor.x = 0.5;
      digit.anchor.y = 0.5;

      // make digit interactive
      digit.interactive = true;
      digit.on("mouseover",
        function(data) {
          this.bringToFront();
          this.tint = 0x000000;
          if(!animating) animate(); //repaint
        });
      digit.on("mouseout",
        function mouseout(data){
          this.tint = 0xFFFFFF;
          if(!animating) animate(); //repaint
  		  });

      stage.addChild(digit);
      digits.push(digit);
    });

    // Add an overlay for the iteration label.
    var box = label.node().getBBox();

    var overlay = svg.append('rect')
          .attr('class', 'overlay')
          .attr('x', box.x)
          .attr('y', box.y)
          .attr('width', box.width)
          .attr('height', box.height)
          .on('mouseover', enableInteraction);

    // stop spinner
    spinner.stop();

    // Start a transition that interpolates the data based on iteration.
    svg.transition()
        .duration(animationDuration * maxIteration)
        .ease('linear')
        .tween('iteration', tweenIteration)
        .each('end', enableInteraction);

    // After the transition finishes, you can mouseover to change the iteration.
    function enableInteraction() {
      var iterationScale = d3.scale.linear()
          .domain([1, maxIteration])
          .range([box.x + 10, box.x + box.width - 10])
          .clamp(true);

      // Cancel the current transition, if any.
      svg.transition().duration(0);
      animating = false;

      overlay
          .on('mouseover', mouseover)
          .on('mouseout', mouseout)
          .on('mousemove', mousemove)
          .on('touchmove', mousemove);

      function mouseover() {
        label.classed('active', true);
      }

      function mouseout() {
        label.classed('active', false);
      }

      function mousemove() {
        displayIteration(iterationScale.invert(d3.mouse(this)[0]));
      }
    }

    // Tweens the entire chart by first tweening the iteration, and then the data.
    // For the interpolated data, the dots and label are redrawn.
    function tweenIteration() {
      var iteration = d3.interpolateNumber(1, maxIteration);
      return function(t) { displayIteration(iteration(t)); };
    }

    // find cumulative maximum absolute value for axis
    var xmaxs = [], ymaxs = [];
    d3.range(0, iterations.length).reduce(function (acc, i) {
      var xmax = Math.max(acc[0], results.map(function(d) { return Math.abs(d.pos[i].x); }).max() * 1.1); // small padding
      var ymax = Math.max(acc[1], results.map(function(d) { return Math.abs(d.pos[i].y); }).max() * 1.1); // small padding

      xmaxs.push(xmax);
      ymaxs.push(ymax);

      return  [xmax, ymax];
    }, [0, 0]);

    // Updates the display to show the specified iteration.
    function displayIteration(iteration) {
      var interpolated = interpolateData(iteration);

      // TODO: smooth x/y maxs out here
      var itr = bisect.left(iterations, Math.ceil(iteration) - 1);
      updateScale([-xmaxs[itr], xmaxs[itr]], [-ymaxs[itr], ymaxs[itr]]);
      // xScale.domain([-xmaxs[itr], xmaxs[itr]]);
      // yScale.domain([-ymaxs[itr], ymaxs[itr]]);
      // zoom.x(xScale).y(yScale);
      // xAxisElement.call(xAxis);
      // yAxisElement.call(yAxis);

      interpolated.forEach(function(data, i) {
        // unadjust zoom translate
        digits[i].position.x = xScale0(data.x) + margin.left;
        digits[i].position.y = yScale0(data.y) + margin.top;
      });
      //animate(); // repaint
      renderMapbox(); // also repaint minimap
      label.text(pad(Math.round(iteration), 3));
    }

    // Interpolates the dataset for the given (fractional) iteration.
    var bisect = d3.bisector(function(d) { return d; });
    function interpolateData(iteration) {
      var i = bisect.left(iterations, iteration);
      return results.map(function(d) {
        return {
          key: d.key,
          label: d.label,
          x: interpolateValues(d.pos, function(d) { return d.x; }, i, iteration),
          y: interpolateValues(d.pos, function(d) { return d.y; }, i, iteration)
        };
      });
    }

    // Finds (and possibly interpolates) the value for the specified iteration.
    function interpolateValues(values, getter, i, iteration) {
      if (i > 0) {
        var ta = iterations[i], tb = iterations[i - 1],
            t = (iteration - ta) / (tb - ta);
        return getter(values[i]) * (1 - t) + getter(values[i - 1]) * t;
      }
      return getter(values[i]);
    }

    // Left pad number with '0'
    function pad(n, width, z) {
      z = z || '0';
      n = n + '';
      return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
    }

    // create stats object
    javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();stats.domElement.style.cssText='position:fixed;left:0;top:0;z-index:10000';document.body.appendChild(stats.domElement);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//rawgit.com/mrdoob/stats.js/master/build/stats.min.js';document.head.appendChild(script);})()

    animate();
  });
});

// TODO: Set hitarea to a polygon
function drawSprite(row) {
  return new PIXI.Sprite(PIXI.Texture.Draw(function (canvas) {
    //we are now in a 2D context
    //you need to specify your canvas width and height otherwise it'll have a size of 0x0 and you'll get an empty sprite
    canvas.width = 28;
    canvas.height = 28;

    var ctx = canvas.getContext('2d');  //get  canvas 2D context
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    var pix = ctx.createImageData(canvas.width, canvas.height);
    var color = d3.rgb(colorScale(row[0]));
    for (var x = 0; x < canvas.width; x++) {
      for(var y = 0; y < canvas.height; y++) {
        var i = x * canvas.width + y + 1;
        var j = y * canvas.width + x + 1;
        pix.data[i * 4 - 4] = color.r;
        pix.data[i * 4 - 3] = color.g;
        pix.data[i * 4 - 2] = color.b;
        pix.data[i * 4 - 1] = row[j];
      }
    }

    ctx.putImageData(pix, 0, 0);
  }));
}


// create the root of the scene graph
var container = new PIXI.Container(); // outer container
var view = new PIXI.Container(); // main view container
var stage = new PIXI.Container(); // complete backstage
view.addChild(stage);
container.addChild(view);

// rectangle mask on main view
var rect = new PIXI.Graphics();
container.addChild(rect);
rect.lineStyle(0);
rect.beginFill(0xFFFFFF, 1);
rect.drawRect(margin.left, 0, width, height + margin.top);
view.mask = rect;

var zoom = d3.behavior.zoom()
    .x(xScale)
    .y(yScale)
    .scaleExtent([1, 10])
    .on("zoom", zoomed);
d3.select('#chart').call(zoom);

function zoomed() {
    //projection.translate(d3.event.translate).scale(d3.event.scale);
    //g.selectAll("path").attr("d", path);
    xAxisElement.call(xAxis);
    yAxisElement.call(yAxis);

    var translate = zoom.translate(), scale = zoom.scale();
    view.position.x = translate[0];
    view.position.y = translate[1];
    view.scale.x = scale;
    view.scale.y = scale;

    // FIXME: The calculation is incorrect.
    mapviewbox.position.x = (translate[0] / minimapScale - minimapWidth) / scale + minimapWidth;
    mapviewbox.position.y = (translate[1] / minimapScale - minimapHeight) / scale + minimapHeight;
    mapviewbox.scale.x = 1 / scale;
    mapviewbox.scale.y = 1 / scale;

    animate();
}

// resume zoom after domain update
function updateScale(newXd, newYd) {
    var translate = zoom.translate(),
        scale = zoom.scale();
    xScale0.domain(newXd);
    yScale0.domain(newYd);
    // Set the zoom x/y-domain (this resets the domain at zoom scale=1).
    zoom.x(xScale.domain(newXd)).y(yScale.domain(newYd)).translate(translate).scale(scale);
    zoomed();
}

// minimap
var minimapScale = 6, minimapWidth = width / minimapScale, minimapHeight = height / minimapScale;
var minimapRenderer = new PIXI.RenderTexture(renderer, width, height, PIXI.SCALE_MODES.NEAREST);
var map = new PIXI.Sprite(minimapRenderer);
map.scale.x = minimapWidth / width;
map.scale.y = minimapHeight / height;
var mapbox = new PIXI.Graphics();
mapbox.lineStyle(1, 0x000000, 0.3);
mapbox.beginFill(0xFFFFFF, 0);
mapbox.drawRect(0, 0, minimapWidth, minimapHeight);
var mapviewbox = new PIXI.Graphics();
mapviewbox.lineStyle(2, 0xFF0000, 0.3);
mapviewbox.beginFill(0xFFFFFF, 0);
mapviewbox.drawRect(0, 0, minimapWidth, minimapHeight);
var minimap = new PIXI.Container();
minimap.position.x = width - minimapWidth + margin.left;
minimap.position.y = 5;
minimap.addChild(mapviewbox);
minimap.addChild(mapbox);
minimap.addChild(map);
var minimapbox = new PIXI.Graphics();
minimapbox.lineStyle(0);
minimapbox.beginFill(0xFFFFFF, 1);
minimapbox.drawRect(0, 0, minimapWidth + 1, minimapHeight + 1);
minimap.addChild(minimapbox);
minimap.mask = minimapbox;
container.addChild(minimap);

function renderMapbox() {
    // render the stage first
    // renderer.render(stage);

    // render minimap texture
    minimapRenderer.clear();
    minimapRenderer.render(stage);

    // render the minimap
    renderer.render(container);
}

function animate() {
    // render root container
    renderer.render(container);

    // request another animation frame..
    // requestAnimationFrame(animate);
}

// PIXI helpers
PIXI.Texture.Draw = function (cb) {
    var canvas = document.createElement('canvas');
    if (typeof cb == 'function') cb(canvas);
    return PIXI.Texture.fromCanvas(canvas);
};

PIXI.Sprite.prototype.bringToFront = function() {
  if (this.parent) {
    var parent = this.parent;
    parent.removeChild(this);
    parent.addChild(this);
  }
};

// Array helpers
Array.prototype.max = function() {
  return Math.max.apply(null, this);
};
</script>
